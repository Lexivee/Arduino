# -*- python -*-
# ex: set syntax=python:

# buildmaster config file. 

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# the 'slaves' list defines the set of allowable buildslaves. Each element is
# a BuildSlave object, which is created with bot-name, bot-password.  These
# correspond to values given to the buildslave's mktap invocation.
from buildbot.buildslave import BuildSlave
c['slaves'] = [BuildSlave("ardutestbot1", "ardtest123434"),
	BuildSlave("ardumacbot1", "ardtest123434"),
	BuildSlave("arduwinbot1", "ardtest123434"),
		]

# 'slavePortnum' defines the TCP port to listen on. This must match the value
# configured into the buildslaves (with their --master option)

c['slavePortnum'] = 9989

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes. Any class which implements IChangeSource can be
# put here: there are several in buildbot/changes/*.py to choose from.

from buildbot.changes.pb import PBChangeSource
c['change_source'] = PBChangeSource()


####### SCHEDULERS

## configure the Schedulers

from buildbot.scheduler import Scheduler
c['schedulers'] = []
test_schedule = Scheduler(name="test", branch="master", treeStableTimer=0, builderNames=["arduino-buildbot-ubuntu-10.04", "arduino-buildbot-macosx-10.6.4", "arduino-buildbot-windowsX"])
c['schedulers'].append(test_schedule)

####### Custom LogParser for Arduino
from buildbot.steps.shell import ShellCommand
from buildbot.process.buildstep import LogLineObserver
from buildbot.status.builder import SUCCESS, FAILURE, WARNINGS, EXCEPTION 
import re
     
#class ArduinoTestCounter(LogLineObserver):
#	numTests = 0
#	def outLineReceived(self, line):
#		if "ok" in line:
#			self.numTests += 1
#			self.step.setProgress('tests', self.numTests)
     
#class ArduinoTest(ShellCommand):
#	command = ["make", "arduinotest"]
#
#	def __init__(self, **kwargs):
#		ShellCommand.__init__(self, **kwargs)   # always upcall!
#		counter = ArduinoTestCounter()
#		self.addLogObserver('stdio', counter)
#		self.progressMetrics += ('tests',)

# Information and code from 
# http://blogs.igalia.com/itoral/2007/02/13/howto-integrate-unit-tests-with-buildbot/
#

class UnitTestsObserver(LogLineObserver):
    regroupfailed = []
    regrouppassed = []
    reunittest = []
    unittests = []

    def __init__(self):
        LogLineObserver.__init__(self)
        if len(self.regroupfailed) == 0:
            self.regroupfailed.append((re.compile('^(.*)(FAIL)$'), 1))
        if len(self.regrouppassed) == 0:
            self.regrouppassed.append((re.compile('^(.*)(ok)$'), 1))
        if len(self.reunittest) == 0:
            self.reunittest.append((re.compile('^([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*).*$'), 4, 5))

    def outLineReceived(self, line):
        matched = False
        for r in self.regroupfailed:
            result = r[0].search(line)
            if result:
                self.step.failedTestsCount += 1
                self.step.testsResults.append((result.groups()[r[1]].strip(), False, self.unittests))
                self.unittests = []
                matched = True
        if not matched:
            for r in self.regrouppassed:
                result = r[0].search(line)
                if result:
                    self.step.passedTestsCount += 1
                    self.step.testsResults.append((result.groups()[r[1]].strip(), True, self.unittests))
                    self.unittests = []
                    matched = True
        if not matched:
            for r in self.reunittest:
                result = r[0].search(line)
                if result:
                    err_msg = result.groups()[r[2]].strip()
                    if err_msg == "Passed":
                        self.unittests.append((result.groups()[r[1]].strip(), True, err_msg))
                    else:
                        self.unittests.append((result.groups()[r[1]].strip(), False, err_msg))
                    matched = True
                    
                    


class ArduinoTestCmd(ShellCommand):
    command=["make", "arduinotest"]
    description="Arduino Testing"
    descriptionDone="Arduino Default Test Done"
    failedTestsCount = 0
    passedTestsCount = 0
    testsResults = []

    def __init__(self, stage=None,module=None, moduleset=None, **kwargs):
        ShellCommand.__init__(self, **kwargs)
        self.failedTestsCount = 0
        self.passedTestsCount = 0
        self.testsResults = []
        testFailuresObserver = UnitTestsObserver ()
        self.addLogObserver('stdio', testFailuresObserver)

    def createSummary(self, log):
        if self.failedTestsCount > 0 or self.passedTestsCount > 0:
            #self.addHTMLLog ('tests summary', "<pre>" + log.getText() + "</pre>")
	    self.addHTMLLog ('tests summary', self.createTestsSummary(log))
	    self.descriptionDone = [self.getTestName(log.getText())]

    def getText(self, cmd, results):
        text = ShellCommand.getText(self, cmd, results)
        if self.failedTestsCount > 0 or self.passedTestsCount > 0:
            text.append("tests failed: " + str(self.failedTestsCount))
            text.append("tests passed: " + str(self.passedTestsCount))
        return text

    def getTestName(self, log):
	for line in log.splitlines():
            if line.startswith('info.Test-Suite-Name'):
		testname = line.split('= ')[1]
                return testname
        return None


    def evaluateCommand(self, cmd):
        if self.failedTestsCount > 0:
            return FAILURE
        else:
            return SUCCESS

    def createTestsSummary(self,log):
        # Create a string with your html report and return it
	return "<pre>" + log.getText() + "</pre>"

#class Nose(ShellCommand):
#    def __init__(self, stage=None,module=None, moduleset=None, **kwargs):
#        command = ['nosetests', '--with-coverage', '--cover-erase', '--cover-html']
#     
#    def describe(self, done=False):
#        if not done:
#            return 'testing'
#        else:
#            return 'test done'
# 
#   def createSummary(self, log):
#        buildnumber = self.getProperty('buildnumber')
#        coverage_index = (self.coverage_path + '/index.html') % buildnumber
#        f = open(coverage_index)
#        m = re.search(r'Percent: (\d+) %', f.read())
#        f.close()
#        self.addURL("coverage %s%%" % m.group(1), 
#                    self.coverage_url % buildnumber)


######## BUILDERS
from buildbot.process import factory
from buildbot.steps import source, shell
#from buildbot.steps.python_twisted import Trial


test_factory = factory.BuildFactory()
test_factory.addStep(source.Git(repourl='git://github.com/ricklon/Arduino.git', branch='master',  shallow=True))
test_factory.addStep(shell.ShellCommand, command=['git','log','-1'], descriptionDone="Latest Change from Git Log")
test_factory.addStep(shell.ShellCommand, command=['ant'],  workdir='build/build')
test_factory.addStep(ArduinoTestCmd( command=["make", "arduinotest"], descriptionDone="Arduino Tests", workdir='build/test/examples'))
test_factory.addStep(ArduinoTestCmd( command=["make", "test"], descriptionDone="Arduino Tests All", workdir='build/test/examples'))
test_factory.addStep(ArduinoTestCmd( command=["make", "success"], descriptionDone="Arduino Tests Success", workdir='build/test/examples'))
test_factory.addStep(ArduinoTestCmd( descriptionDone="Arduino Tests Default", workdir='build/test/examples'))
test_factory.addStep(ArduinoTestCmd ( command=["make", "bogus"], descriptionDone="Arduino bogus make target", workdir='build/test/examples'))
test_factory.addStep(ArduinoTestCmd( command=["make", "failure"], descriptionDone="Shell Arduino Tests Failure",workdir='build/test/examples'))



b1 = {'name': "arduino-buildbot-ubuntu-10.04",
      'slavename': "ardutestbot1",
      'builddir': "ArduinoUbuntu",
      'factory': test_factory,
      }

b2 = {'name': "arduino-buildbot-macosx-10.6.4",
      'slavename': "ardumacbot1",
      'builddir': "ArduinoMacOSX",
      'factory': test_factory,
      }

b3 = {'name': "arduino-buildbot-windowsX",
      'slavename': "arduwinbot1",
      'builddir': "ArduinoWindowsX",
      'factory': test_factory,
      }

c['builders'] = [b1, b2, b3]


####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

# Use allowForce=True (boolean, not a string. ie: not 'True') to allow
# Forcing Builds in the Web User Interface. The default is False.
from buildbot.status import html
c['status'].append(html.WebStatus(http_port=8010,allowForce=True))

#from buildbot.status import html
#c['status'].append(html.WebStatus(http_port=8010))

# from buildbot.status import mail
# c['status'].append(mail.MailNotifier(fromaddr="buildbot@localhost",
#                                      extraRecipients=["builds@example.com"],
#                                      sendToInterestedUsers=False))
#
from buildbot.status import words
c['status'].append(words.IRC(host="irc.freenode.net", nick="ardbot", channels=["#arduinobuild"]))
#
# from buildbot.status import client
# c['status'].append(client.PBListener(9988))


####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually committing changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

#c['debugPassword'] = "debugpassword"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole("tcp:9999:interface=127.0.0.1",
#                                       "admin", "password")


####### PROJECT IDENTITY

c['projectName'] = "Arduino"
c['projectURL'] = "http://arduino.cc"

c['buildbotURL'] = "http://localhost:8010/"
