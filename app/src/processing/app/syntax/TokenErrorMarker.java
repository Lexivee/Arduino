package processing.app.syntax;

import java.awt.Color;

import javax.swing.text.Element;

import org.fife.ui.rsyntaxtextarea.RSyntaxDocument;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import org.fife.ui.rsyntaxtextarea.Token;
import org.fife.ui.rsyntaxtextarea.TokenMaker;
import org.fife.ui.rsyntaxtextarea.modes.CPlusPlusTokenMaker;
import org.fife.ui.rsyntaxtextarea.parser.AbstractParser;
import org.fife.ui.rsyntaxtextarea.parser.DefaultParseResult;
import org.fife.ui.rsyntaxtextarea.parser.DefaultParserNotice;
import org.fife.ui.rsyntaxtextarea.parser.ParseResult;
import org.fife.ui.rsyntaxtextarea.parser.ParserNotice;

/**
 * Displays Syntax errors at the level of tokens, these errors are generated by {@link TokenMaker} like {@link CPlusPlusTokenMaker}
 * TODO: Currently he is the parser of the entire document, I am waiting for the resolution of the bug below. (maybe this class is to removed)
 * https://github.com/bobbylight/RSyntaxTextArea/issues/86
 * @author Ricardo JL Rufino (ricardo@criativasoft.com.br)
 */
public class TokenErrorMarker extends AbstractParser {
  
  private RSyntaxTextArea textarea;
  private DefaultParseResult result;
  
  public TokenErrorMarker(RSyntaxTextArea textarea) {
    setEnabled(true);
    this.textarea = textarea;
    result = new DefaultParseResult(this);
  }
  
  @Override
  public ParseResult parse(RSyntaxDocument doc, String style) {

    Element root = doc.getDefaultRootElement();
    int lineCount = root.getElementCount();
    
    result.clearNotices();
    result.setParsedLines(0, lineCount-1);
    
    for (int line=0; line<lineCount; line++) {
      parseTokensErrors(doc, line);
    }
    return result;
  }
  
  private boolean parseTokensErrors(RSyntaxDocument doc,int line){
    
    boolean found = false;
    
    Token t = doc.getTokenListForLine(line);
    int start = -1;
    int end = -1;

    while (t!=null) {
      if (isError(t)) {
        if(start == -1) start = t.getOffset();
      }else{
        if(start > 0 && end == -1) end =  t.getOffset();
      }
      t = t.getNextToken();
    }

    if (start>-1) {
      DefaultParserNotice pn = new DefaultParserNotice(this, "syntax error", line, start, (end-start));
      pn.setLevel(ParserNotice.Level.ERROR);
      pn.setColor(Color.RED);
      result.addNotice(pn);
      found = true;
    }
    
    return found;
  }
  
  private boolean isError(Token token){
    
    switch (token.getType()) {
      case Token.ERROR_CHAR:
      case Token.ERROR_IDENTIFIER:
      case Token.ERROR_NUMBER_FORMAT:
      case Token.ERROR_STRING_DOUBLE:
        return true;
    }
    
    return false;
  }

}
